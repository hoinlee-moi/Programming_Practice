> # 가비지 컬렉션
<br>
JS는 눈에 보이지 않는 곳에서 메모리 관리를 수행한다.<br>
원시값, 객체, 함수 등 우리가 만드는 모든 것은 메모리를 차지한다.<br>
그러면 더는 쓸모 없어지게 된 것들은 어떻게 처리될까??<br>
<br>
<br>

### 가비지 컬렉션 기준
<br>
JS는 도달 가능성(reachability)이라는 개념을 사용해 메모리 관리를 수행한다.<br>
'도달 가능한(reachable)'값은 쉽게 말해 어떻게든 접근하거나 사용할 수 있는 값을 의미한다.<br>
 도달 가능한 값은 메모리에서 삭제되지 않음!<br>
 <br>

 1. 아래 나올 값들은 그 태생부터 도달 가능하기 때문에, 명백한 이유 없이는 삭제되지 않는다.<br>
 EX)<br>

 - 현재 함수의 지역 변수와 매개변수
 - 중첩 함수의 체인에 있는 함수에서 사용되는 변수와 매개변수
 - 전역 변수
 - 기타 등등

 이런 값은 루트(root)라고 부른다.<br>
 <br>
 
 2. 루트가 참조하는 값이나 체이닝으로 루트에서 참조할 수 있는 값은 도달 가능한 값이 된다.<br>

 <br>
전역 변수에 객체가 저장되어 있다고 가정해 보자.<br>
이 객체의 프로퍼티가 또 다른 객체를 참조하고 있다면, 프로퍼티가 참조하는 객체는 도달 간으한 값이 된다.<br>
이 객체가 다른 모든 것들도 도달 가능하다고 여겨지는데 자세한 예시를 봐보자.

<br>

자바스크립트 엔진 내에선 **가비지 컬렉터(garbage collector)가 끊임없이 동작한다<br>
가비지 컬렉터는 모든 객체를 모니터링하고, 도달할 수 없는 개체는 삭제한다.<br>

<br>

### 간단한 예시

<br>

```javascript
// user엔 객체 참조 값이 저장된다.
let user = {
    name: "john"
};
```
<br>

전역 변수 "user"는 `{name: "John"} (줄여서 John)이라는 객체를 참조한다.<br>
John의 프로퍼티 "name"은 원시값을 저장하고 있기 때문에 객체 안에 표현했습니다.<br>
`user`의 값을 다른 값으로 덮어쓰면 참조(화살표)가 사라진다.

```javascript
user = null;
```

이제 John은 도달할 수 없는 상태가 되었다. John에 접근할 방법도, John을 참조하는 것도 모두 사라짐<br>
가비지 컬렉터는 이제 John에 저장된 데이터를 삭제하고, John을 메모리에서 삭제한다.<br>
<br>

### 참조 두 개

<br>

참조를 `user`에서 `admin`으로 복사했따고 가정해보자.

```javascript
// user엔 객체 참조 값이 저장된다.
let user = {
    name : "John"
};

let admin = user;
```

그리고 위에서 한 것처럼 `user`의 값을 다른 값으로 덮어써 보자.

```javascript
user = null;
```

전역 변수 `admin`을 통하면 여전히 객체 John에 접근할 수 있기 때문에 John은 메모리에서 삭제되지 않는다.<br>
이 상태에서 `admin`을 다른 값(null 등)으로 덮어쓰면 John은 메모리에서 삭제될 수 있다

<br>

### 연결된 객체

<br>

이제 가족관계를 나타내는 복잡한 예시를 살펴보자.
```javascript
function marry(man, woman) {
  woman.husband = man;
  man.wife = woman;

  return {
    father: man,
    mother: woman
  }
}

let family = marry({
  name: "John"
}, {
  name: "Ann"
});
```
함수 `marry`(결혼하다)는 매개변수로 받은 두 객체를 서로 참조하게 하면서 '결혼'시키고, 두 객체를 포함하는 새로운 객체를 반환한다.
<br>
<br>
지금은 모든 객체가 도달 가능한 상태이다.<br>
참조 두개를 지워보자<br>
```javascript
delete family.father;
delete family.mother.husband;
```
삭제한 두 개의 참조 중 하나만 지웠다면, 모든 객체가 여전히 도달 가능한 상태일 것이다.<br>
하지만 참조 2개를 지우면 John으로 들어오는 참조는 모두 사라져 John은 도달 가능한 상태에서 벗어난다.<br>
<br>
외부로 나가는 참조는 도달 가능한 상태에 영향을 주지 않는다. 외부에서 들어오는 참조만이 도달 간으한 상태에 영향을 준다.<br>
John은 이제 도달 가능한 상태가 아니기 때문에 메모리에서 제거됩니다.<br>
John에 저장된 데이터(프로퍼티) 역시 메모리에서 사라진다.<br>

<br>
<br>

### 도달할 수 없는 섬

<br>

객체들이 연결되어 섬 같은 구조를 만드는데, 이 섬에 도달할 방법이 없는 경우, 섬을 구성하는 객체 전부가 메모리에서 삭제된다.<br>
근원 객체 `family` 가 아무것도 참조하지 않도록 해보자.
```javascript
family = null;
```
이제 메모리 내부 상태는 단절된다.<br>
<br>
도달할 수 없는 섬 예제는 도달 가능성이라는 개념이 얼마나 중요한지 보여준다.<br>
John과 Ann은 여전히 서로를 참조하고 있고, 두 객체 모두 외부에서 들어오는 참조를 갖고 있지만, 이것만으로는 충분하지 않다는 걸 보여준다.<br>
"family"객체와 루트의 연결이 사라지면 루트 객체를 참조하는 것이 아무것도 없게된다.<br>
섬 전체가 도달할 수 없는 상태가 되고, 섬을 구성하는 객체 전부가 메모리에서 제거 된다.
<br>
<br>

### 내부 알고리즘

<br>

'mark-and-sweep'이라 불리는 가비지 컬렉션 기본 알고리즘에 대해 알아보자.<br>
'가비지 컬렉션'은 대개 다음 단계를 거쳐 수행된다.<br>

- 가비지 컬렉터는 루트(root)정보를 수집하고 이를 'mark(기억)'한다.
- 루트가 참조하고 있는 모든 객체를 방문하고 이것들을 'mark'한다.
- mark된 모든 객체에 방문하고 그 객체들이 참조하는 객체도 mark한다. 한번 방문한 객체는 전부 mark하기 때문에 같은 객체를 다시 망분하는 일은 없다.
- 루트에서 도달 가능한 모든 객체를 방문할 때까지 위 과정을 반복한다.
- mark되지 않은 모든 객체를 메모리에서 삭제한다.

<br>
<br>
루트에서 페인트를 들이 붓는다고 상상하면 이 과정을 이해하기 쉽다.<br>
루트를 시작으로 참조를 따라가면서 도달 가능한 객체 모두에 페인트가 칠해진다고 생각하면 된다.<br>
이때 페인트가 묻지 않은 객체는 메모리에서 삭제<br>
<br>
JS엔진은 실행에 영향을 미치지 않은면서 가비지 컬렉션을 더 빠르게 하는 다양한 최적화 기법을 적용한다.<br>

<br>

**최적화 기법** :
- **generational collection** (세대별 수집) - 객체를 '새로운 객체'와 '오래된 객체'로 나눈다<br>
객체 상당수는 생성 이후 제 역할을 빠르게 수행해 금방 쓸모가 없어지는데, 이런 객체를 '새로운 객체'로 구분한다.<br>
가비지 컬렉터는 이런 객체를 공격적으로 메모리에서 제거하는데 일정 시간 이상 동안 살아남은 객체는 '오래된 객체'로 분류하고, 가비지 컬렉터가 덜 감시한다.
- **incremental collection** (점진적 수집) - 방문해야 할 객체가 많다면 모든 객체를 한 번에 방문하고 mark 하는데 상당한 시간이 소모된다.<br>
가비지 컬렉션에 많은 리소스가 사용되어 실행 속도도 눈에 띄게 느려지는데 JS엔진은 이런 현상을 개선하기 위해 가비지 컬렉션을 여러 부분으로 분리한 다음, 각 부분을 별도로 수행한다.<br>
작업을 분리하고, 변경 사항을 추적하는 데 추가 작업이 필요하긴 하지만, 긴 지연을 짧은 지연 여러 개로 분산시킬 수 있다는 장점이 있다.
- **idle-time collection (유휴 시간 수집)** - 가비지 컬렉터는 실행에 주는 영향을 최소화 하기 위해 CPU가 유휴 상태일 때만 가비지 컬렉션을 실행한다.<br>

<br>

이 외에도 다양한 최적화 기법과 가비지 컬렉션 알고리즘이 있다.<br>
다만 엔진마다 세부 사항이나 기법이 다르며 엔진이 발전하면 기법도 달라지기 때문에 학습해야할 이유가 없다면 '심화'학습은 그리 가치가 있지는 않다.<br>

>## 요약
지금까지 알아본 내용을 요약해 봅시다.

가비지 컬렉션은 엔진이 자동으로 수행하므로 개발자는 이를 억지로 실행하거나 막을 수 없습니다.
객체는 도달 가능한 상태일 때 메모리에 남습니다.
참조된다고 해서 도달 가능한 것은 아닙니다. 서로 연결된 객체들도 도달 불가능할 수 있습니다.