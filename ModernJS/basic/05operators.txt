1.기본 연산자와 수학

- 피연산자(operand)는 연산자가 연산을 수행하는 대상. 5 * 2 에는 왼쪽 피연산자 5와 오른쪽 피연산자 2, 총 2개의 피연산자가 있습니다. '피연산자'는 인수(argument)라는 용어로 불림
- 피연산자를 하나만 받는 연산자는 단항(unary) 연산자 라고 부릅니다. 피연산자의 부호를 뒤집는 단항 마이너스 연산자 -는 닪아 연산자의 대표적인 예입니다.

let x = 1;

x = -x;
alert( x ) ; // -1, 단항 마이너스 연산자는 부호를 뒤집습니다.

- 두개의 피 연산자를 받는 연산자는 이항(binary) 연산자라고 부릅니다. 마이너스 연산자는 아래와 같이 이항 연산자로 쓸 수도 있다.

let x = 1, y = 3;
alert( y - x ); // 2, 이항 마이너스 연산자는 뺄셈을 해준다.

위와 같이 부호를 반전해주는 단항 마이너스 연산자와 뺄셈에 쓰이는 이항 마이너스 연산자(뺄셈 연산자)는 기호는 같지만 수행하는 연산이 다름.


수학

- 덧셈 연산자 +
- 뺄셈 연산자 -
- 곱셈 연산자 *
- 나눗셈 연산자 /
- 나머지 연산자 %
- 거듭제곱 연산자 **

- - -

2.나머지 연산자 %

나머지 연산자(remainder operator)는 % 기호로 나타내지만, 비율을 나타내는 퍼센트와 관련이 없다.
나머지 연산자를 사용한 표현식 a % b 는 a를 b로 나눈 후 그 나머지(remainder)를 정수로 반환해준다.

alert( 5 % 2 ); // 5를 2로 나눈 후의 나머지인 1을 출력
alert( 8 % 3 ); // 8을 3으로 나눈 후의 나머지인 2를 출력

- - -

3.거듭제곱 연산자 **

거듭제곱 연산자(exponentiation operator)를 사용한 a ** b 를 평가하면 a를 b번 곱한 값이 반환

alert( 2 ** 2 ); // 4  (2 * 2)
alert( 2 ** 3 ); // 8  (2 * 2 * 2)
alert( 2 ** 4 ); // 16 (2 * 2 * 2 * 2)

거듭제곱 연산자는 정수가 아닌 숫자에 대해서도 동작하는데 1/2를 사용하면 제곱근을 구할 수 있다.

alert( 4 ** (1/2) ); // 2 (1/2 거듭제곱은 제곱근)
alert( 8 ** (1/3) ); // 2 (1/3 거듭제곱은 세제곱근)

- - -

4.이항 연산자 '+'와 문자열 연결

덧셈 연산자 +는 대개 숫자를 더한 결과를 반환하는데 이항 연산자 +의 피연산자로 문자열이 전달되면 덧셈 연산자는 덧셈이 아닌 문자열을 병합(연결)한다.

let s = "my" + "string";
alert(s); // mystring;

따라서 이항 연산자 +를 사용할 때는 피연산자 중 하나가 문자열이면 다른 하나도 문자열로 변환된다는 점에 주의해야 한다.

alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"

연산은 왼쪽에서 오른쪽으로 순차적으로 진행되기 때문에 두 개의 숫자 뒤에 문자열이 오는 경우, 숫자가 먼저 더해지고, 그 후 더해진 숫자와 문자열과의 병합이 일어난다.
이처럼 이항 덧셈 연산자 +는 문자열 열결과 반환이라는 특별한 기능을 제공하는데 다른 산술 연산자가 오직 숫자형의 피연산자만 다루고, 피 연산자가 숫자형이 아닌 경우에 그 형을 숫자형으로
바꾸는 것과는 대조적이다.

alert(2 + 2 + '1' ); // '221'이 아니라 '41'이 출력됩니다.
alert( 6 - '2' ); // 4, '2'를 숫자로 바꾼 후 연산이 진행됩니다.
alert( '6' / '2' ); // 3, 두 피연산자가 숫자로 바뀐 후 연산이 진행됩니다.

- - -

5.단항 연산자 +와 숫자형으로의 변환

덧셈 연산자 +는 이항 연산자뿐만 아니라 단항 연산자로도 사용할 수 있다.
숫자에 단항 연산자를 붙이면 아무런 동작도 하지 않지만 피연산자가 숫자가 아닌 경우엔 숫자형으로의 변환이 일어난다.

// 숫자에는 아무런 영향을 미치지 않습니다.
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

// 숫자형이 아닌 피연산자는 숫자형으로 변화합니다.
alert( +true ); // 1
alert( +"" );   // 0

Number(...)와 동일한 일을 해준다.

let apples = "2";
let oranges = "3";

alert( apples + oranges ); // 23, 이항 덧셈 연산자는 문자열을 연결합니다.

let apples = "2";
let oranges = "3";

// 이항 덧셈 연산자가 적용되기 전에, 두 피연산자는 숫자형으로 변화합니다.
alert( +apples + +oranges ); // 5

// `Number(...)`를 사용해서 같은 동작을 하는 코드를 작성할 수 있지만, 더 기네요.
// alert( Number(apples) + Number(oranges) ); // 5

하지만 나는 아래가 더 옳다고 생각한다. Number처럼 정확하게 타입을 얘기하고 정확하게 들어가야 짧은 코딩이라면 괜찮지만 몇천줄 되는
길고 커다란 프로젝트에선 무지하게 안좋을 것 같다. 그래서 typescript를 쓰는 거 같다.

- - -

6.할당 연산자

무언가를 할당할 때 쓰이는 = 도 연산자이다. 이 연산자는 할당(assignment) 연산자라고 불리는데 우선순위는 3으로 아주 낮다
그래서 x = 2*2+2 같은 표현식에서 계산이 먼저 이뤄지고, 그 결과가 x에 할당된다.

let x = 2 * 2 + 1;

alert( x ); // 5

값을 반환하는 할당 연산자

=는 연산자이기 때문에 흥미로운 함축성을 내포하고 있는데 js에서 대부분의 연산자들은 값을 반환한다. +와-분만 아니라 = 역시 값을 반환
x=value을 호출하면 value가 x에 쓰여지고, 이에 더하여 value가 반환

let a = 1;
let b = 2;

let c = 3 - (a = b + 1);

alert( a ); // 3
alert( c ); // 0

(a=b+1)은 a에 값을 할당하고, 그 값인 3을 반환, 그리고 반환 값은 이어지는 표현식에 사용
다만 이런 코드는 코드가 명확하지 않을 뿐만 아니라 가독성도 떨어지기 때문에 쓰지 않기를 권장

- - - 

7.할당 연산자 체이닝

할당 연산자는 여러개를 연결할 수도 있다.(체이닝)

let a, b, c;

a = b = c = 2 + 2;

alert( a ); // 4
alert( b ); // 4
alert( c ); // 4

이렇게 할당 연산자를 여러 개 연결한 경우, 평가는 우측부터 진행된다. 가장 우측의 2+2가 평가되고, 그 결과가 좌측의 c,b,a에 순차적으로 할당된다.
하지만 되도록 연산자를 체이닝 하는 것보다 가독성을위해

c = 2 + 2;
b = c;
a = c;

이런식으로 작성을 하자.

- - -

8.복합 할당 연산자

let n = 2;
n = n + 5;
n = n * 2;

이 때 +=와 *= 연산자를 사용하여 짧은 문법으로 동일한 연산을 수행할 수 있다.

let n = 2;
n += 5; // n은 7이 됩니다(n = n + 5와 동일).
n *= 2; // n은 14가 됩니다(n = n * 2와 동일).

alert( n ); // 14

이런 '복합 할당' 연산자는 산술 연산자와 비트 연산자에도 적용할 수 있다. /=, -=등의 연산자도 가능
복합 할당 연산자의 우선순위는 할당 연산자와 동일하며 대부분 다른 연산자가 실행된 후에 복합 할당 연산자가 실행됨

let n = 2;

n *= 3 + 5;

alert( n ); // 16  (*=의 우측이 먼저 평가되므로, 위 식은 n *= 8과 동일)

- - -

9.증가 감소 연산자가

숫자를 하나 늘리거나 줄일 때 자주 사용되는 연산은

- 증가 연산자 ++는 변수를 1 증가시킴

let counter = 2;
counter++;      // counter = counter + 1과 동일하게 동작합니다. 하지만 식은 더 짧습니다.
alert( counter ); // 3

- 감소 연산자 --는 변수를 1 감소시킴

let counter = 2;
counter--;      // counter = counter - 1과 동일하게 동작합니다. 하지만 식은 더 짧습니다.
alert( counter ); // 1

중요!! 증가,감소 연산자는 변수에만 쓸 수 있다. 5++같이 값에 사용하려고 하면 에러 발생

후위형 : 피연산자 뒤에 올 때 count++
전위형 : 피연산자 앞에 올 때 ++count

후위형 전위형 둘 다 피 연산자인 counter를 1만큼 증가시켜준다는 점은 동일하다.
차이는 반환값을 사용할 때 드러남

let counter = 1;
let a = ++counter; // (*)

alert(a); // 2

-----------------------------------------------------

let counter = 1;
let a = counter++; // (*) ++counter를 counter++로 바꿈

alert(a); // 1

(*)줄에 표시한 전위 후위형으로 값이 다른데 정리하자면

- 반환 값을 사용하지 않는 경우라면, 전위형과 후위형엔 차이가 없다.
- 값을 증가시키고 난 후, 증가한 값을 바로 사용하려면 전위형 증가 연산자를 사용하면 됨
- 값을 증가시키지만, 증가전의 기존값을 사용하려면 후위형 증가 연산자를 사용하면 됨

- - -

10. 비트 연산자가

비트 연산자(bitwise operator)는 인수를 32비트 정수로 변환하여 이진 연산을 수행
비여 연산 시 쓰이는 연산자 목록

- 비트 AND ( & )
- 비트 OR ( | )
- 비트 XOR ( ^ )
- 비트 NOT ( ~ )
- 왼쪽 시프트(LEFT SHIFT) ( << )
- 오른쪽 시피트(RIGHT SHIFT) ( >> )
- 부호 없는 오른쪽 시프트(ZERO-FILL RIGHT SHIFT) ( >>> )

다만 비트 연산자는 저수준(2진 표현)에서 숫자를 다뤄야 할 때 쓰이므로 흔하게 쓰이진 않는다. 암호를 다뤄야 할 땐 비트 연산자가 유용함

- - -

11. 쉼표 연산자가

쉼표 연산자(comma operator) , 는 좀처럼 보기 힘들고 특별한 연산자.
코드를 짧게 쓰려는 의도로 가끔 사용 되는데 어떤 연산 결과가 도출되는지 알아야 함!

쉼표 연산자는 여러 표현식을 코드 한 줄에서 평가할 수 있게 해준다. 이때 표현식 각각이 모두 평가되지만, 마지막 표현식의 평가 결과만 반환되는 점에 유의

let a = (1 + 2, 3 + 4);

alert( a ); // 7 (3 + 4의 결과)

위 예시에서 첫 번째 포현식 1+2는 평가 되지만 그 결과는 버려짐. 3+4만 평가되어 a에 할당


※쉼표의 우선순위는 매우 낮다.
쉼표 연산자의 연산자 우선순위는 매우 낮은데 할당 연산자인 =보다 더 낮음. 따라서 괄호가 중요한 역할은 한다(위 예시)
괄호가 없으면 a= 1+2, 3+4 에서 + 가 먼저 수행되어 a = 3, 7이 됨. 할당 연산자 =는 쉼표 연산자보다 우선순위가 높기 때문에 a = 3이 먼저 실행되고, 나머지 (7)는 무시된다.
(a = 1 +2), 3 + 4 를 연산한 것처럼 됨

이렇게 마지막 표현식을 제외한 모든 것을 버리는 연산자가 어디서 사용되는지??
여러 동작을 하나의 줄에서 처리하려는 복잡한 구조에서 이를 사용

// 한 줄에서 세 개의 연산이 수행됨
for (a = 1, b = 3, c = a * b; a < 10; a++) {
 ...
}

코드 가독성이 좋지 않으니 진짜 필요한 경우에만 사용하자!