01.비교연산자

자바스크립트에서 기본 수학 연산은 아래와 같다

- 보다 큼,작음 : a > b, a < binary
- 보다 크거나, 작거나 같음 : a >= b, a <= binary
- 같음(동등) : a == b. 등호 =가 두 개 연달아 오는 것에 유의! a = b 와같이 등호가 하나일 땐 할당을 의미
- 같지 않음(부등) : 같지 않음을 나타내는 수학기호는 ≠ 이지만 JS에선 a != b 로 나타낸다. 할당연산자 = 앞에 !표를 붙여서 표시


- - -

02. 불린형 반환

다른 연산자와 마찬가지로 비교 연산자 역시 값을 반환, 반환 값은 불린형

- true 가 반환되면 '긍정', '참', '사실'을 의미
- false 가 반환되면 '부정', '거짓', '사실이 아님'을 의미

alert( 2 > 1 );  // true
alert( 2 == 1 ); // false
alert( 2 != 1 ); // true

반환된 불린 값은 다른 여타 값처럼 변수에 할당 할 수 있다.

let result = 5 > 4; // 비교 결과를 변수에 할당
alert( result ); // true

- - -

03. 문자열 비교연산자

JS는 '사전'순으로 문자열을 비교한다. '사전편집(lexicographical)'순이라 불리기도 하는 기준을 적용하면 사전 뒤쪽의 문자열은 사전 앞쪽의 문자열보다 크다고 판단.

alert( 'Z' > 'A' ); // true
alert( 'Glow' > 'Glee' ); // true
alert( 'Bee' > 'Be' ); // true

문자열 비교 알고리즘

- 두 문자열의 첫 글자를 비교
- 첫 번째 문자열의 첫 글자가 다른 문자열의 첫 글자보다 크면(작으면), 첫 번째 문자열이 두 번째 문자열보다 크다고(작다고) 결론 내고 비교를 종료
- 두 문자열의 첫 글자가 같으면 두 번째 글자를 같은 방식으로 비교를
- 글자 간 비교가 끝날 때까지 이 과정을 반복
- 비교가 종료되었고 문자열의 길이도 같다면 두 문자열은 동일하다고 결론, 비교가 종료되었지만 두 문자열의 길이가 다르면 길이가 긴 문자열이 더 크다고 결론


※ 정확히는 사전순이 아니라 유니코드 순이다.
[JS의 문자열 비교 알고리즘은 사전이나 전화번호부에서 사용되는 정렬 알고리즘과 아주 유사하지만 같지는 않음.
차이점 중 하나가 대.소문자를 따짐. 대문자 'A'와 소문자 'a'를 비교했을 때 소문자 'a'가 더 크다.
인코딩 표인 유니코드에선 소문자가 대문자보다 더 큰 인덱스를 가지고 있기 때문]


- - -

03. 다른 형을 가진 값 간의 비교

비교하려는 값의 자료형이 다르면 JS는 이 값들을 숫자형으로 바꿈

alert( '2' > 1 ); // true, 문자열 '2'가 숫자 2로 변환된 후 비교가 진행됩니다.
alert( '01' == 1 ); // true, 문자열 '01'이 숫자 1로 변환된 후 비교가 진행됩니다.

불린값의 경우 true는 1, false는 0으로 변환된 후 비교가 이뤄진다.

alert( true == 1 ); // true
alert( false == 0 ); // true

※하지만 이런 문제로 Typescript가 더 많이 쓰이는 상황. 정확한 자료형 검사로 큰 프로젝트에서 오류를 잡기 위해


- - -

04. 일치 연산자
=== 사용
※자세하게 다루지 않는 이유는 typescript를 이용할 경우 false와 0을 비교하는 그런 형식은 없어지 때문 -개인적 의견-

- - -

05. null이나 undefined와 비교하기

null이나 undefined를 다른 값과 비교할 때 몇가지 규ㅣㄱ이 있다.

- 일치 연산자 ===를 사용하여 null과 undefined를 비교
두 값의 자료형이 다르기 때문에 일치 비교 시 거짓이 반환

alert( null === undefined ); // false

- 동등 연산자 ==를 사용하여 null과 undefined를 비교
동등 연산자를 사용해 null과 undefined를 비교하면 특별한 규칙이 적용돼 true가 반환됨.
동등 연산자는 null과 undefined를 '각별한 커플’처럼 취급하는데 두 값은 자기들끼리는 잘 어울리지만 다른 값들과는 잘 어울리지 못한다.

alert( null == undefined ); // true

- 산술 연산자나 기타 비교 연산자 <, >, <=, >=를 사용하여 null과 undefined를 비교
null과 undefined는 숫자형으로 변환됩니다. null은 0, undefined는 NaN으로 변함


06. null vs 0

alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true

(3)에서 null은 0보다 크거나 같다고 했기 때문에 (1)이나 (2) 중 하나는 참이여야 하는데 둘 다 거짓을 반환한다.
이런 결과는 동등연산자 == 과 기타 비교 연산자 <,>,<=,>= 의 동작 방식이 다르기 때문
null > 0이 거짓을, (3)에서 null >= 0이 참을 반환하는 이유는 (기타 비교 연산자의 동작 원리에 따라) null이 숫자형으로 변환돼 0이 되기 때문

그런데 동등 연산자 ==는 피연산자가 undefined나 null일 때 형 변환을 하지 않는다.
그래서 undefined와 null을 비교하는 경우에만 true를 반환하고, 그 이외의 경우(null이나 undefined를 다른 값과 비교할 때)는 무조건 false를 반환, 때문에 (2)는 거짓을 반환한다.


07. 비교가 불가능한 undefined

undefined를 다른 값과 비교해서는 안된다.

alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)

- (1)과(2)에선 undefined가 NaN으로 변환되는데(숫자형으로의 변환), NaN이 피연산자인 경우 비교 연산자는 항상 false를 반환합니다.
- undefined는 null이나 undefined와 같고, 그 이외의 값과는 같지 않기 때문에 (3)은 false를 반환합니다.

이와 같은 케이스를 살펴본 이유는 함정을 피하기 위해선데

08. 함정 피하기

- 일치 연산자 === 를 제외한 비교 연산자의 피연산자에 undefined나 null이 오지 않도록 특별히 주의
- undefined나 null이 될 가능성이 있는 변수가 <,>,<=,>= 의 피연산자가 되지 않도록 주의!
명확한 의도를 갖고 있지 않는 이상, 만약 변수가 undefined나 null이 될 가능성이 있다고 판단되면 이를 따로 처리하는 코드를 추가하길 권장